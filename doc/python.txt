1. python /usr/bin/python in debian

2.1 解释器。
    Ctrl-D让python解释器以0状态码退出, 或者用quit()来退出解释器
    Ctrl-P 检查是否支持命令行编辑。发出声音则支持。
         Ctrl-A 将光标移动到行首， C-E移动到行尾，C-B左移一个字符，C-F右移一位。
         退格左删除一个字符串，C-D右删除一个字符。C-K删除光标右边直到行尾的所有字符。C-Y将最后一次删除的字符串粘贴到光标位置，C_下划线撤销最后一次修改。
         注意：Ctrl下划线需要终端支持。 有些终端这个是缩小。需要去~/.inputc来修改。
    也可以用python -c command [arg]在命令行执行python语句，一般建议用单引号包裹语句防止空格或者其他特殊shell字符。
    也可以对python模块当作脚本使用，python -m module [arg] 来调用。使用脚本文件，经常会运行脚本并且进入交互模式，可以通过在脚本之前加上-i参数实现。

    2.1.1参数传递
        
    2.1.2 交互模式。
        主提示符 >>> 从属提示符...
        输入多行结构就需要从属提示符。
            >>> the_world_flag=1
            >>> if the_world_flag:
            ...     print "Be careful!"
            ... 
            Be careful!
    2.2.1 错误处理
        异常可以由 try 语句中的 except 子句来控制，这样就不会出现上文中的错误信息
        在主提示符或从属提示符中输入中断符（通常是 Control-C 或者 DEL）就会取消当前输入，回到主命令行。 [1] 执行命令时输入一个中断符会抛出一个 KeyboardInterrupt 异常，它可以被 try 语句截获。

    2.2.2 执行python脚本
        加类似shell的,并且可以指定执行模式和权限,chmod +x script.py
        #! /usr/bin/env python
        如果需要指定其他的字符编码。指定编码必须在文件的第一行或者第二行定义。
            # -*- coding: encoding -*-
        例如
            # -*- coding: cp-1252 -*-
    2.2.4 交互执行文件。
        在每次解释器启动时执行一些命令,你可以在一个文件中包含你想要执行的命令，设定一个名为 PYTHONSTARTUP 的环境变量来指定这个文件。这类似于 Unix shell 的 .profile 文件。
        想要在当前目录中执行附加的启动文件，可以在全局启动文件中加入类似以下的代码： if os.path.isfile('.pythonrc.py'): execfile('.pythonrc.py') 。如果你想要在某个脚本中使用启动文件，必须要在脚本中写入这样的语句:
            import os
            filename = os.environ.get('PYTHONSTARTUP')
            if filename and os.path.isfile(filename):
                exec(open(filename).read())
    2.2.5. 本地化模块
        Python 提供了两个钩子（方法）来本地化: sitecustomize 和 usercustomize
            >>> import site
            >>> site.getusersitepackages()
            '/home/user/.local/lib/python2.7/site-packages'
        现在你可以在 site-packages 的目录下创建 usercustomize.py 文件，内容就悉听尊便了。 这个文件将会影响 python 的每次调用，除非启动的时候加入 -s 选项禁止自动导入。

3. Python 简介
    3.1
        一个值可以同时赋给几个变量:
            a,b = 2,3  意思就是a=2,b=3  a=b=2 意思就是a，b都等于2
        变量在使用前必须“定义”（赋值），否则会出错:
        浮点数有完整的支持；与整型混合计算时会自动转为浮点数:
            >>> 3 * 3.75 / 1.5
            7.5
            >>> 7.0 / 2
            3.5
        复数也得到支持；带有后缀 j 或 J 就被视为虚数。带有非零实部的复数写为 (real+imagj) ，或者可以用 complex(real, imag) 函数创建
            >>> 1j * 1J
            (-1+0j)
            >>> 1j * complex(0, 1)
            (-1+0j)
            >>> 3+1j*3
            (3+3j)
            >>> (3+1j)*3
            (9+3j)
            >>> (1+2j)/(1+1j)
            (1.5+0.5j)
        复数的实部和虚部总是记为两个浮点数。要从复数 z 中提取实部和虚部，使用 z.real 和 z.imag
        复数a+bi中，a称为复数的实部，b称为复数的虚部，i称为虚数单位。当虚部等于零时，这个复数就是实数；当虚部不等于零时，这个复数称为虚数，复数的实部如果等于零，则称为纯虚数
            >>> a=1.5+0.5j
            >>> a.real
            1.5
            >>> a.imag
            0.5
        浮点数和整数之间的转换函数（ float() 和 int() 以及 long() ） 不能用于复数。没有什么正确方法可以把一个复数转成一个实数。函数 abs(z) 用于获取其模（浮点数）或 z.real 获取其实部:
            >>> a=3.0+4.0j
            >>> float(a)
            Traceback (most recent call last):
              File "<stdin>", line 1, in ?
            TypeError: can't convert complex to float; use abs(z)
            >>> a.real
            3.0
            >>> a.imag
            4.0
            >>> abs(a)  # sqrt(a.real**2 + a.imag**2)
            5.0
        交互模式中，最近一个表达式的值赋给变量 _ 。这样我们就可以把它当作一个桌面计算器，很方便的用于连续计算
            >>> tax = 12.5 / 100
            >>> price = 100.50
            >>> price * tax
            12.5625
            >>> price + _
            113.0625
            >>> round(_, 2)
            113.06
    3.1.2. 字符串
        Python 也提供了可以通过几种不同方式传递的字符串。它们可以用单引号或双引号标识:
            >>> 'spam eggs'
            'spam eggs'
            >>> 'doesn\'t'
            "doesn't"
            >>> "doesn't"
            "doesn't"
            >>> '"Yes," he said.'
            '"Yes," he said.'
            >>> "\"Yes,\" he said."
            '"Yes," he said.'
            >>> '"Isn\'t," she said.'
            '"Isn\'t," she said.'
        Python 解释器按照字符串被输入的方式打印字符串结果：为了显示准确的值，字符串包含在成对的引号中，引号和其他特殊字符要用反斜线（ \ ）转译。 如果字符串只包含单引号（ ‘ ）而没有双引号（ ” ）就可以用双引号（ ” ）包围，反之用单引号（ ‘ ）包围。 再强调一下， print 语句可以生成可读性更好的输出。可以使用反斜杠为行结尾的连续字符串，它表示下一行在逻辑上是本行的后续内容
        需要注意的是，还是需要在字符串中写入 \n ——结尾的反斜杠会被忽略
        字符串可以标识在一对三引号中： """ 或 ''' 。三引号中，不需要行属转义
            print """\
            Usage: thingy [OPTIONS]
                 -h                        Display this usage message
                 -H hostname               Hostname to connect to
            """
            得到如下输出:
            Usage: thingy [OPTIONS]
                 -h                        Display this usage message
                 -H hostname               Hostname to connect to
        字符串可以由 + 操作符连接（粘到一起），可以由 * 重复:

            >>> word = 'Help' + 'A'
            >>> word
            'HelpA'
            >>> '<' + word*5 + '>'
            '<HelpAHelpAHelpAHelpAHelpA>'
        相邻的两个字符串文本自动连接在一起，前面那行代码也可以写为 word ='Help' 'A';它只用于两个字符串文本，不能用于字符串表达式:
            >>> 'str' 'ing'                   #  <-  This is ok
            'string'
            >>> 'str'.strip() + 'ing'   #  <-  This is ok
            'string'
            >>> 'str'.strip() 'ing'     #  <-  This is invalid
              File "<stdin>", line 1, in ?
                'str'.strip() 'ing'
                                  ^
            SyntaxError: invalid syntax
        字符串也可以被截取（检索）。类似于 C ，字符串的第一个字符索引为 0 。没有独立的字符类型，字符就是长度为 1 的字符串。类似 Icon ，可以用 切片标注 法截取字符串：由两个索引分割的复本。
            >>> word[4]
            'A'
            >>> word[0:2]
            'He'
            >>> word[2:4]
            'lp'
        索引切片可以有默认值，切片时，忽略第一个索引的话，默认为 0，忽略第二个索引，默认为字符串的长度:
            >>> word[:2]    # The first two characters
            'He'
            >>> word[2:]    # Everything except the first two characters
            'lpA'
        不同于 C 字符串，Python 字符串不可变。向字符串文本的某一个索引赋值会引发错误:
            >>> word[0] = 'x'
            Traceback (most recent call last):
              File "<stdin>", line 1, in ?
            TypeError: 'str' object does not support item assignment
            >>> word[:1] = 'Splat'
            Traceback (most recent call last):
              File "<stdin>", line 1, in ?
            TypeError: 'str' object does not support slice assignment
        切片操作有个有用的不变性： s[:i] + s[i:] 等于 s。
            >>> word[:2] + word[2:]
            'HelpA'
            >>> word[:3] + word[3:]
            'HelpA'
        Python 能够优雅地处理那些没有意义的切片索引：一个过大的索引值（即下标值大于字符串实际长度）将被字符串实际长度所代替，当上边界比下边界大时（即切片左值大于右值）就返回空字符串。
            >>> word[1:100]
            'elpA'
            >>> word[10:]
            ''
            >>> word[2:1]
            ''
        索引也可以是负数，这将导致从右边开始计算。 例如:
            >>> word[-1]     # The last character
            'A'
            >>> word[-2]     # The last-but-one character
            'p'
            >>> word[-2:]    # The last two characters
            'pA'
            >>> word[:-2]    # Everything except the last two characters
            'Hel'
        请注意 -0 实际上就是 0 ，所以它不会导致从右边开始计算！
            >>> word[-0]     # (since -0 equals 0)
            'H'
        负索引切片越界会被截断，不要尝试将它用于单元素（非切片）检索:
            >>> word[-100:]
            'HelpA'
            >>> word[-10]    # error
            Traceback (most recent call last):
              File "<stdin>", line 1, in ?
            IndexError: string index out of range
        有个办法可以很容易地记住切片的工作方式：切片时的索引是在两个字符 之间 。左边第一个字符的索引为0，，而长度为 n 的字符串其最后一个字符的右界索引为 n 。例如:
             +---+---+---+---+---+
             | H | e | l | p | A |
             +---+---+---+---+---+
             0   1   2   3   4   5
            -5  -4  -3  -2  -1
        文本中的第一行数字给出字符串中的索引点 0...5 。第二行给出相应的负索引。切片是从 i 到 j 两个数值标示的边界之间的所有字符。
        对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如， word[1:3] 是 2 。
        内置函数 len() 返回字符串长度:
            >>> s = 'supercalifragilisticexpialidocious'
            >>> len(s)
            34

    3.1.3. 关于 Unicode
        Python 中创建 Unicode 字符串和创建普通的字符串一样简单:
            >>> u'Hello World !'
            u'Hello World !'
        引号前的 'u' 表示这会创建一个 Unicode 字符串。如果想要在字符串中包含特殊字符，可以使用 Python 的 Unicode-Escape 。请看下面的例子:
            >>> u'Hello\u0020World !'
            u'Hello World !'
        和普通字符串一样， Unicode 字符串也有原始模式。可以在引号前加 “ur”，Python 会采用 Raw-Unicode-Escape 编码。如果有前缀为 ‘u’ 的数值，它也只会显示为 uXXXX 。
            >>> ur'Hello\u0020World !'
            u'Hello World !'
            >>> ur'Hello\\u0020World !'
            u'Hello\\\\u0020World !'
        内置函数 unicode() 可以使用所有注册的 Unicode 编码（ COders 和 DECoders ）
    3.1.4. 列表
        Python 有几个 复合 数据类型，用于表示其它的值。最通用的是 list (列表) ，它可以写作中括号之间的一列逗号分隔的值。列表的元素不必是同一类型。
            >>> a = ['spam', 'eggs', 100, 1234]
            >>> a
            ['spam', 'eggs', 100, 1234]
        字符串索引，列表从 0 开始检索。列表可以被切片和连接:
            >>> a[0]
            'spam'
            >>> a[3]
            1234
            >>> a[-2]
            100
            >>> a[1:-1]
            ['eggs', 100]
            >>> a[:2] + ['bacon', 2*2]
            ['spam', 'eggs', 'bacon', 4]
            >>> 3*a[:3] + ['Boo!']
            ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']
        所有的切片操作都会返回新的列表，包含求得的元素。这意味着以下的切片操作返回列表 a 的一个浅拷贝的副本:
            >>> a[:]
            ['spam', 'eggs', 100, 1234]
        不像 不可变的 字符串，列表允许修改元素
            >>> a
            ['spam', 'eggs', 100, 1234]
            >>> a[2] = a[2] + 23
            >>> a
            ['spam', 'eggs', 123, 1234]
        也可以对切片赋值，此操作可以改变列表的尺寸，或清空它:
            >>> # Replace some items:
            ... a[0:2] = [1, 12]
            >>> a
            [1, 12, 123, 1234]
            >>> # Remove some:
            ... a[0:2] = []
            >>> a
            [123, 1234]
            >>> # Insert some:
            ... a[1:1] = ['bletch', 'xyzzy']
            >>> a
            [123, 'bletch', 'xyzzy', 1234]
            >>> # Insert (a copy of) itself at the beginning
            >>> a[:0] = a
            >>> a
            [123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
            >>> # Clear the list: replace all items with an empty list
            >>> a[:] = []
            >>> a
            []
        内置函数 len() 同样适用于列表:
            >>> a = ['a', 'b', 'c', 'd']
            >>> len(a)
            4
        允许嵌套列表（创建一个包含其它列表的列表），例如:
            >>> q = [2, 3]
            >>> p = [1, q, 4]
            >>> len(p)
            3
            >>> p[1]
            [2, 3]
            >>> p[1][0]
            2
        你可以在列表末尾添加内容:
            >>> p[1].append('xtra')
            >>> p
            [1, [2, 3, 'xtra'], 4]
            >>> q
            [2, 3, 'xtra']
    3.2. 编程的第一步
        交互式录入复合语句时，必须在最后输入一个空行来标识结束（因为解释器没办法猜测你输入的哪一行是最后一行），需要注意的是同一个语句块中的每一行必须缩进同样数量的空白。
        一个逗号结尾就可以禁止输出换行:

4. 深入 Python 流程控制
    4.1 if
        >>> x = int(raw_input("Please enter an integer: "))
        Please enter an integer: 42
        >>> if x < 0:
        ...      x = 0
        ...      print 'Negative changed to zero'
        ... elif x == 0:
        ...      print 'Zero'
        ... elif x == 1:
        ...      print 'Single'
        ... else:
        ...      print 'More'
        ...
        More
    4.2 for
        Python 中的 for 语句和 C 或 Pascal 中的略有不同。通常的循环可能会依据一个等差数值步进过程（如 Pascal），或由用户来定义迭代步骤和中止条件（如 C ），Python 的 for 语句依据任意序列（链表或字符串）中的子项，按它们在序列中的顺序来进行迭代
        >>> # Measure some strings:
        ... a = ['cat', 'window', 'defenestrate']
        >>> for x in a:
        ...     print x, len(x)
        ...
        cat 3
        window 6
        defenestrate 12
    在迭代过程中修改迭代序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。如果你想要修改你迭代的序列（例如，复制选择项），你可以迭代 它的复本。使用切割标识就可以很方便地做到这一点:
        >>> for x in a[:]: # make a slice copy of the entire list
        ...    if len(x) > 6: a.insert(0, x)
        ...
        >>> a
        ['defenestrate', 'cat', 'window', 'defenestrate']
