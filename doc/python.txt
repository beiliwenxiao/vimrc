x = input("x:") 获取用户输入
2**3 = pow(2,3) 幂运算符**,乘方
round           四舍五入最接近的整数。
abs             绝对值
1//2            整除
1.0/2           浮点运算
19000000000L    L就是长整数
0xAF            十六进制
010             八进制
import 来导入模块
    import math
    math.floor(32.9) 会取整 =32.0
    要输出为整数
    int(math.floor(32.9)) 输出32,自动向下取整,所以可以直接int(32.9)
    要输出向上的整数，ceil
    math.ceil(32.9) 输出33, 32.0 =32 32.1=33

from模块import函数来指定。就不要在每次调用函数的时候都写模块名字
    sqrt是math里面计算一个数的平方根
    from math import sqrt
    sqrt(9)   输出3.0
    也可以用变量来引用函数foo=math.sqrt
        foo(4) = 2.0

sqrt(-1) 会输出nan/NAN 意思就是not a number 非数值
要处理负数的平方根（负数的平方根是虚数),需要用cmath(complex math,复数)模块
    import cmath
    cmath.sqrt(-1) 输出1j  j/J就是虚数,不使用from cmath import sqrt是怕命名冲突污染
        虚数相乘为-1
        >>>(1+3j)* (8+4j)
        8+4j+24j-12 = -4+28j

python IDE /idle
#apt-get install idle-python2.7

raw_input("Press <enter>") 来提供交互,
    与input不同，input会假设用户输入的都是合法的python表达式，而raw_input会把所有的输入当作原始数据(raw data)
    所有如果也是获取用户输入,如果是数字,需要进行转换.int(raw_input(''))

str函数， 把值转换为合理形式的字符串, str实际是一种类型,类似int/long，repr是函数。
repr函数，创建一个字符串以合法的python表达式的形式来表示值
    >>>print repr("Hello, world!")
    'Hello, world!'
    >>>print repr(10000L)
    10000L
    >>>print str("Hello, world!")
    Hello, world!
    >>>print str(10000L)
    10000
    repr也可以作为`x` 反引号的实现。
    >>>temp = 42
    >>>print "The temperature is " + `temp` 就不会报错,python3不再使用反引号，所以应该用repr


长字符串用'''string'''来包围,或者"""string""" 里面可以随意用单双引号。
如果一行的最后一个字符是反斜杠\ 换行符本身就转义而被忽略掉

原始字符串
    为了解决>>>path = "C:\nowhere"
            >>>path
            'C:\nowhere'
            >>>print path
            C:
            owhere
    对于短的，可以再转义一次
            >>print "c:\\nowhere"
            c:\nowhere
    对于长的，加上r表示原始字符串,原始字符串的最后一个字符不能是反斜线，除非转义,因为不知道是否应该结束字符串,如果非要原始字符串以一个反斜杠结尾，把这个反斜线作为一个字符串处理
        >>>print r'Let\'s go!'
        Let\'s go!
        >>>print r'C:\Program Files\foo\bar' '\\'
        C:\Program Files\foo\bar\

Unicode字符串,在python3.0，所有字符串都是unicode字符串
    u"hello, world1"

数据结构

    sequence 序列,python有6种序列,包括列表，元组，字符串，Unicode字符串，buffer对象，xrange对象
        列表可以修改，元组不能修改
    python中还有一种名叫容器container的数据结构。 容器就是包含其他对象的任意对象。
    序列（例如和元组）和映射（例如字典） 是两类主要的容器。 序列中的每个元素都有自己的编号，而映射中的每个元素则右一个名字（键）。集合set是既不是序列也不是映射的容器类型。

    所有序列都可以进行某些特定操作,索引indexing,分片slicing,加adding，乘multiplying
    以及检查某个元素是否属于序列的成员（成员资格）。除此之外，python还有计算序列长度，找出最大元素，最小元素的内建函数
    迭代iteration，对序列进行迭代的意思，就是依次对序列中的每个元素重复执行某些操作。
    字符串就是一个由字符组成的序列。索引0指向第一个元素

    分片slicing.可以指定步长step length,步长不能为0
        >>>numbers = [1,2,3,4,5,6,7,8,9,10]
        >>>numbers[0:10:2]  #[1,3,5,7,9]
        >>>numbers[::3]     #[1,4,7,10]
        >>>numbers[8:3:-1]  #[9,8,7,6,5]

    空列表，[]
    None python内建值，表示没有在里面放置任何元素
    初始化一个长度10的列表
        >>>sequence = [None] * 10
        >>>sequence
        [None,None,None,None,None,None,None,None,None,None]

    成员资格用in运算符,返回True/False
    内建函数len 返回序列包含元素的数量
    内建函数min/max返回序列中最大/最小的元素

    list函数，实现字符串可以像列表一样被修改,list也适用于所有类型的序列。
        >>>list('Hello')
        ['H','e','l','l','o']
        可以用''.join(somelist)来把列表转换为字符串

    分片赋值,可以赋值不等长的序列
        >>>name=list('perl')
        >>>name[2:]=list('ar')
        >>>name
        ['p','e','a','r']
    列表方法
        append/count/extend/index/insert/pop/remove/reverse/sort
        pop是唯一一个既能修改列表又返回元素值(除了None)的列表方法

    元组，不可变的序列
    用逗号分割值，就自动创建了元组,元组大部分是通过圆括号括起来的。可以用没有那个的两个圆括号表示空元组
        >>>42  #42
        >>>42, #(42,)
        >>>(42,) #(42,)
        >>>3*(40+2)  #126
        >>>3*(40+2,)  #(42,42,42)
    tuple函数,以一个序列作为参数并把它转换为元组。 如果参数是元组就原样返回
        >>>tuple([1,2,3]) #(1,2,3)
        >>>tuple('abc') #('a','b','c')
        >>>typle(1,2,3) #(1,2,3)
    元组操作
        >>>x=1,2,3 #x = (1,2,3)
        >>>x[1] #2
        >>>x[0:2] (1,2)
    cmp函数cmp(x,y) 比较两个值。1,0,-1


    格式化字符串，字符串格式化操作符%, %s是转换说明符conversion specifier, 标记了需要插入转换值的位置，s表示值会被格式化成字符串，如果不是字符串，会用str将其转换为字符串
        如果格式化字符串有百分号。就用%%，这样python就不会将百分号误认为是转换说明符了。
        >>>format = "Hello, %s. %s enough for ya?"
        >>>values = ('world','Hot')
        >>>print format %s vlaues
        Hello, world. Hot enough for ya?
    格式化浮点数,f和精度 如%.3f是小数点后保留3位。 因为格式化转换说明符总是以表示类型的字符结束，所以精度在类型字符的前面
        >>>format = "Pi with three 10 decimals: %.10f"
        >>>from math import pi
        >>>print format % pi
        Pi with 10 decimals:3.1415926536

    string模块提供另外一种格式化方法,模板字符串,substitute模板方法会用传递进来的关键字参数foo替换掉字符串中的$foo
        >>>from string import Template
        >>>s = Template('$x,glorious $x!')
        >>>s.substitute(x='slurm')
        'slurm. glorious slurm!'
    如果替换字段是单词的一部分，参数名需要用括号括起来 ${x}
    可以使用$$插入美元符号,除了关键字参数以外，还可以使用字典变量提供值/名称对
        >>>s=Template('A $thing must never $action.')
        >>>d={}
        >>>d['thing'] = 'gentleman'
        >>>d['action'] = 'show his socks'
        >>>s.substitute(d)
        'A gentleman must never show his socks.'
    如果格式化的右边(右操作数)是元组的话,则其中的每一个元素都会被单独格式化.每个值都需要一个对应的转换说明符
    如果需要转换的元组作为转换表达式的一部分存在,那么必须将它用圆括号括起来.
        >>>'%s plus $s equals $s' % (1,1,2)
        '1 plus 1 equals 2'
    字符串转换类型
        %标记转换说明符的开始
        转换标志(可选)-表示左对齐,+表示在转换值之前要加上正负号,""空白字符表示正数之前保留空格,0表示转换值若位数不够则用0填充
        最小字段宽度(可选),转换后的字符串至少应该具有该值指定的宽度.如果是*,则宽度会从元组中读取 
        点. 后跟精度值(可选),如果转换的是实数,精度值会表示在小数点后的位数.  如果转换的是字符串,那么该数字就表示最大字段宽度,如果是*,精度会从元组中读书
            d,i     带符号的十进制整数
            o       不带符号的八进制
            u       不带符号的十进制
            x       不带符号的十六进制 小写
            X       不带符号的十六进制 大写
            e       科学计数法表示的浮点数 小写
            E       科学计数法表示的浮点数 大写
            f,F     浮点数
            g       如果指数大于-4或者小于精度值则和e相同.其他情况和f相同
            G       如果指数大于-4或者小于精度值则和E相同.其他情况和F相同
            C       单字符 接受整数或者单字符字符串
            r       字符串  使用repr转换任意python对象
            s       字符串 使用str转换任意python对象
        注意,比如%10f % pi 会取
        3.141593,因为不带精度的时候会默认为6的精度.整数位不足会补空值.所以在字段宽度和精度前
            >>> from math import  pi
            >>> '%010f' % pi
            '003.141593'
            >>> '-%10f' % pi
            '-  3.141593'
            >>> '%-10f' % pi
            '3.141593  '
            >>> '%+10f' % pi
            ' +3.141593'
            >>> '%10f' % pi
            '  3.141593'

    字符串方法. 来源于string模块.
        >>>import string
        >>>string.字符串方法

        find方法在一个较长的字符串中查找子串.返回子串所在位置的最左端索引. 没找到返回-1
        find('子串',[起始点],[结束点]) []是可选的参数 
        join是split方法的逆方法,用来连接序列中的元素(元素必须是字符串)
            >>> a = ['1','2','3']
            >>> b = '+'
            >>> b.join(a)
            '1+2+3'
        lower返回字符串的小写版, 相反的是title方法,会把所有单词的首字母大写. 但是可能不自然, 用string模块的capwords函数.
        string.capitalize 返回首字母大写的字符串的副本.
        string.center(width[, fillchar])  返回一个长度为max(len(string), width)且string的副本居中的字符串,两侧使用fillchar填充
        string.count(sub[, start[, end]]) 计算子字符串出现的次数,可以限定搜索范围
        string.decode([encoding[, errors]])
        string.encode([encoding[, errors]])
        string.endswith(suffix[, start[,end]]) 检查string是否以suffix结尾
        string.expandtabs([tabsize]) 返回字符串副本,其中tab字符会以默认8个空格扩展,可以选tab以几个空格
        string.find(sub[, start[,end]]) 返回子字符串的第一个索引,不存在返回-1
        string.index(sub[, start[,end]])返回子字符串的第一个索引,找不到索引的时候引发valueError异常
        string.isalnum()    检查字符串是否由字母/数字字符组成
        string.isalpha()    检查是否由字母字符组成
        string.isdigit()    检查是否由数字组成
        string.islower()    检查是否都为小写
        string.istitle()    检查是否不基于实例的字母后面的基于实例的字符都是答谢,且其他的基于实例的字符都是小写
        string.isspace()    检查字符串是否由空格组成
        string.isupper()    检查基于实例的字符都是答谢
        string.join(sequence)   返回其中sequence的字符串元素已用string连接的字符串
        string.ljust(width[, fillchar]) 返回一个长度为max且其中string的副本左对齐的字符串,右侧使用fillchar默认空字符填充
        string.lower()  返回一个字符串的副本,所有基于实例的字符都是小写
        string.lstrip([chars])  返回去除开始处所有char的字符串副本,默认char为空白字符,比如空格,tab,换行符
        string.partition(sep)   在字符串中搜索sep并返回(head,sep,tail)
        string.replace(old, new[, max]) 替换
        string.rfind(sub[, start[, end]]) 返回找到的最后一个索引,不存在返回-1
        string.rindex(sub[,start[,end]])  返回被找到的最后一个索引,不存在返回valueerror
        string.rjust(width[,fillchar])  返回右对齐,左侧用fillchar填充的字符串
        string.rpartition(sep)  同partition,但是从右侧开始查找
        string.rstrip([chars])  同strip,不过是从字符串结束处去除.
        string.rsplit([sep[, maxsplit]]) 同split,但是在使用maxsplit的时候是从右向左计数
        string.split([sep[, maxsplit]]) 返回字符串中所有单词的列表,使用sep作为分隔符(如没指定则以空格切分,可使用maxsplit来指定最大切分数)
            a = 'a hello wolrd a, you\'are so beautiful'
            >>> a.split()
            ['a', 'hello', 'wolrd', 'a,', "you'are", 'so', 'beautiful']
            >>> a.split(',')
            ['a hello wolrd a', " you'are so beautiful"]
        string.splitlines([keepends]) 返回所有string中所有行的列表,可选择是否包括换行符,如提供keepends则包括
            >>> import string
            >>> a = '123132asdfew'
            >>> print a
            123132asdfew
            >>> a.splitlines()
            ['123132asdfew']
        string.startswidth(prefix[,start[,end]]) 检查string是否以prefix开头, 可以用开始,结束来指定匹配范围
        string.strip([chars])   默认为空格的chars都从开头和结尾去除(不包括内部).默认为所有空白字符,包括空格.tab.换行符
        string.swapcase()   交换大小写
        string.title()  返回字符串的副本,单词以大写字母开头, 包括i'm => I'M, 可以用capwords函数来处理i'm => I'm
        string.translate(table[, deletechars])  返回字符串的副本,其中所有字符都使用table替换, 可选择删除出现在deletechars中的所有字符
            替换换行符,等,优势在于可以同时进行多个替换.有时候比replace效率高.
            转换前需要一个转换表table, 可以用maketrans函数来, maketrans接受两个参数, 两个等长的字符串,来表示第一个字符串中的每个字符都要用第二个字符串中相同位置的字符替换.
                >>>from string import maketrans
                >>>table = maketrans('cs', 'kz')
            转换表是包含替换ASCII字符集中256个字符的替换字母的字符串
                >>>table = maketrans('cs', 'kz')
                >>>len(table)
                256
                >>>table[97:123]
                'abkdefghijklmnopqrztuvwxyz'
                >>>maketrans('', '')[97,123]
                'abcdefghijklmnopqrstuvwxyz'
        string.upper()  返回字符串的副本,其中所有基于实例的字符都是大写的
        string.zfill(width) 在string的左侧以0填充width个字符


    字典,mapping,键可以是数字,字符串,元组., 字典是python中唯一内建的映射类型.
        字典的key是唯一的,如果重复,会以最后一个key的value为value
        创建字典 a = {'alice':'234','bb':'23','cc':'32'}
            >>> a = {'a':'23','b':'23','c':'321321','a':'32'}
            >>> a
            {'a': '32', 'c': '321321', 'b': '23'}
            >>> a['a']
            '32'
            >>> a['a']='hello'
            >>> a
            {'a': 'hello', 'c': '321321', 'b': '23'}
            >>> 'c' in a
            True
            >>> del a['a']
            >>> a
            {'c': '321321', 'b': '23'}
        key键类型是任意的不可变类型,比如浮点,实型,字符串,元组等.
        键如果不存在,当赋值的时候会自动创建
        成员资格, k in d(d为字典)查找的是键,不是值,表达式v in l(l为列表l)则是用来查找值的,而不是索引
        在字典中检查键的成员资格比在列表中检查值的成员资格更高效,数据结构规模越大,两者效率差距越明显.
            >>> x=[]            #空列表
            >>> x[42]='foobar'
            Traceback (most recent call last):
              File "<pyshell#109>", line 1, in <module>
                x[42]='foobar'
            IndexError: list assignment index out of range
                #可以用 [NONE]*43来初始化列表x
                    >>> x=[None]*43
                    >>> x
                    [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]
                    >>> x[42]='foobar'
                    >>> x
                    [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'foobar']
            >>> x={}            #空字典
            >>> x[42]='foobar'
            >>> x
            {42: 'foobar'}

    字典方法
        aDict.clear()   移除aDict所有的项
        aDict.copy()    返回aDict的副本
            copy是浅复制shallow copy,内存中实际是一份,可以使用深复制deep copy,
                >>> from copy import deepcopy
                >>> d = {}
                >>> d['name'] = ['tommyxia','rainysia']
                >>> c = d.copy()
                >>> dc = deepcopy(d)
                >>> d['name'].append('yuliang.xia')
                >>> c
                {'name': ['tommyxia', 'rainysia', 'yuliang.xia']}
                >>> dc
                {'name': ['tommyxia', 'rainysia']}
                >>> d.clear()
                >>> c
                {'name': ['tommyxia', 'rainysia', 'yuliang.xia']}
                >>> dc
                {'name': ['tommyxia', 'rainysia']}
                >>> d
                {}
        aDict.fromkeys(seq[,val])   返回从seq中获得的键和被设置为val的值的字典,使用给定的键建立新的字典.每个键都对应一个默认值None
            >>> {}.fromkeys(['name','age'])
            {'age': None, 'name': None}
            >>> dict.fromkeys(['name','age','degree'])
            {'age': None, 'name': None, 'degree': None}
            >>> {}.fromkeys(['name','age'], '(hahah)')
            {'age': '(hahah)', 'name': '(hahah)'}
            dict是所有字典的类型.所以可以直接在dict上调用fromkeys函数
        aDict.get(key[,default])    如果aDict[key]存在,将其返回;否则返回给定的默认值(默认为None)
            >>> d = {}
            >>> d['a']
            Traceback (most recent call last):
              File "<pyshell#169>", line 1, in <module>
                d['a']
            KeyError: 'a'
            >>> d.get('name')
            >>> print d.get('name')
            None
            >>> print d.get('name','N/A')
            N/A
        aDict.has_key(key)          检查aDict是否右给定键key,python3.x不存在
        aDict.items()               返回表示aDict项的(键,值)对列表
        aDict.iteritems()           返回表示aDict项的(键,值)对相同的(键,值)对中返回一个可迭代对象
            >>> d = {'title':'123','name':'tommy','spam':0}
            >>> d
            {'spam': 0, 'name': 'tommy', 'title': '123'}
            >>> d.items()
            [('spam', 0), ('name', 'tommy'), ('title', '123')]
            >>> it = d.iteritems()
            >>> it
            <dictionary-itemiterator object at 0x1333470>
            >>> list(it)
            [('spam', 0), ('name', 'tommy'), ('title', '123')]
        aDict.iteerkeys()           从aDict的键中返回一个可迭代对象
        aDict.itervalues()          从aDict的值中返回一个可迭代对象
        aDict.keys()                返回aDict的键列表
        aDict.pop(key[,d])          移除并且返回给定键key或给定的默认值d的值
        aDict.popitem()             从aDict中移除随机项,并将其作为(键,值)对返回
        aDict.setdefault(key[,default]) 如果aDict[key]存在则将其返回;否则返回给定的默认值(默认为none),并将aDict[key]的值绑定给该默认值(字典中不含有给定键的情况下设定相应的键值)
            >>> d={}
            >>> d.setdefault('name','N.A')
            'N.A'
            >>> d
            {'name': 'N.A'}
            >>> d['name']='tommy'
            >>> d
            {'name': 'tommy'}
            >>> d.setdefault('name','N/A')
            'tommy'
            >>> d
            {'name': 'tommy'}
        aDict.update(other)         将other中的每一项都加入到aDict中,可能会重写已存在的项
        aDict.values()              返回aDict中值的列表(可能包括相同的)
            >>> d = {'1':1,'2':1,'3':3,'4':'ab','5':'21'}
            >>> d
            {'1': 1, '3': 3, '2': 1, '5': '21', '4': 'ab'}
            >>> d.values()
            [1, 3, 1, '21', 'ab']


    语句
        导入的时候,同命名的函数,可以用别名
            from module1 import open as open1
            from module2 import open as open2
            或者
            import module1
            import module2
            module1.open(...)
            module2.open(...)
        序列解包, 将多个值的序列解开,然后放到变量的序列中.
            >>> values = 1,2,3
            >>> values
            (1, 2, 3)
            >>> x,y,z=values
            >>> y
            2
            如果获取/删除字典中任意的键值对,可以用popitem方法.将键值对作为元组返回.然后会复制给两个变量
                >>> scoudrel = {'name':'tommyx','title':'se'}
                >>> key,value=scoudrel.popitem()    #popitem是随机的
                >>> key
                'name'
                >>> value
                'tommyx'
        链式赋值chained assignment
            x = y = somefunction() 等于
            x=somefunction()
            x=y
            可能不等于
            x=somefunction()
            y=somefunction()

        布尔值false 包括
            Flase None 0 "" ()  []              {}
                                空列表/空元组  空字典
        bool函数可以转换其他值为布尔值
            bool([])==bool("")==Flase 但是[]!="" 因为类型不一样

        同一性运算符is, 判断同一性而不是相等性,x,y绑定在同一个列表中,z绑定在另一个具有相同数值和顺序 列表中.它们值那个相等,但是却不是同一个对象
            >>> x=y=[1,2,3]
            >>> z=[1,2,3]
            >>> x==y
            True
            >>> x==z
            True
            >>> x is y
            True
            >>> x is z
            False
        使用==运算符来判定两个对象是否相等, 使用is来判断两者是否等同(同一个对象)
        字符串可以按照字母顺序进行比较
            >>>'alpha' < 'beta'
            True
        三元
            >>> 1 if True else Flase
            1
        断言, assert 条件,后可跟解释性字符串
            >>> age = -1
            >>> assert 0<age<130, "The age must be realistic"
            Traceback (most recent call last):
              File "<pyshell#229>", line 1, in <module>
                assert 0<age<130, "The age must be realistic"
            AssertionError: The age must be realistic
        For循环遍历字典(序列解包)
            >>> d={'x':1,'y':2,'z':'we'}
            >>> for key,value in d.items():
                print key, '==', value

            y == 2
            x == 1
            z == we
            >>> d.items()
            [('y', 2), ('x', 1), ('z', 'we')]
        并行迭代.
            >>> names = ['tom','kevin','susan']
            >>> ages =[28,33,44]
            >>> for i in range(len(names)):
                print names[i], 'is', ages[i], 'years old'

                
            tom is 28 years old
            kevin is 33 years old
            susan is 44 years old

        zip函数压缩后返回一个元组的列表.
            >>> zip(names,ages)
            [('tom', 28), ('kevin', 33), ('susan', 44)]
            >>> for name,age in zip(names,ages):
                print name, 'is', age, 'years old'

                
            tom is 28 years old
            kevin is 33 years old
            susan is 44 years old
        zip函数也可以作用任意多的序列,来处理不等长的序列.当最短的序列"用完"的时候会停止循环.
        这里xrange是一次创建一个数,而range会一次创建整个序列.所以序列越大,xrange越高效,下面代码里xrange只计算了5次,每次1个数.
            >>> zip(range(5), xrange(100000))
            [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

        按索引迭代,也可以用enumerate函数
            >>> index = 0
            >>> for string in strings:
                if 'xxx' in string:
                    strings[index] = '[censored]'
                index +=1

            for index,string in enumerate(strings):
                ...
        翻转/排序迭代 reversed/sorted

        wile True/break
            while True:
                word = raw_input('pls enter a word: ')
                if not word: break
                print 'The word was ' + word

        for else子句, 仅在没有调用break时执行.
        列表推导式list comprehension
            >>>[x*x for x in  range(10)]
            [0,1,4,9,16,25,36,49,64,81]
            >>>[x*x for x in  range(10) if x % 3 == 0]
            [0,9,36,81]
            >>>[(x,y) for x in range(3) for y in range(3)]
            [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]
            等同于
            result = []
            for x in range(3):
                for y in range(3):
                    result.append((x,y))
        pass是为了解决python中空代码块非法.什么都不做
        del语句删除的是名称,而不是删除的值,值是由Python解释器的内存回收的.
        exec/eval可以用in scope来实现作用域,exec是执行一个语句,eval是用于求值的类似exec的内置函数.
            >>> from math import sqrt
            >>> scope = {}
            >>> exec 'sqrt=1' in scope
            >>> sqrt(4)
            2.0
            >>> scope['sqrt']
            1
        eval语句可以提供两个命名空间,一个全局的,必须是字典.局部的可是是任意形式的映射.
        chr(n)函数, 传入序号n时,返回n所代表的包含一个字符的字符串,0<=n<=256
            >>> chr(0)
            '\x00'
            >>> chr(98)
            'b'
        ord(c) 返回单字符字符串的int值
            >>> ord('a')
            97
            >>> 

    Abstract抽象
        2.x callable函数,判断函数是否可以调用
        3.x 弃用callable, 使用hasattr(func, __call__)替代
            >>> import math
            >>> x = 1
            >>> y = math.sqrt
            >>> callable(x)
            False
            >>> callable(y)
            True
    
    def 定义函数, 函数如果没有返回值,默认会返回None
    在函数内部开头写下字符串,这个字符串会作为函数的一部分进行存储,称为文档字符串
    文档字符串可以使用 函数名.__doc__来进行访问. 注意不是注释, 也不需要传参
    内建的help(函数名) 可以得到函数,包括文档字符串的信息.

    函数可以使用关键字参数来传入指定的实参
        >>>def store(patient='test1', name='test2'):
                return patient,name
        如果既有位置参数又有关键字参数, 应该把位置参数放到前面. 避免未定义.

    收集参数. 指定一个参数在前面加上星号,
    就可以传入多个位置参数,并且存在一个元组里面,如果不提供任何供收集的元素,就会是空元组
        def print_params(*params):
            print params

        print_params(1,2,3)     #(1,2,3)
        print_params('Testing') #('Testing',)

        def print_params_2(title, *params):
            print title
            print params

        print_params_2('CEO','Tom','Nico','Deb')    #CEO \n ('Tom', 'Nico', 'Deb')

        print_params_2('CEO')       #CEO \n ()
    注意不能使用关键字参数
        >>>print_params_2(test='CEO', 'Tom')
        File "collect.py", line 17                                                                      
        print_params_2(test='CEO', 'Tom')                                                             
        SyntaxError: non-keyword arg after keyword arg  
    可以使用两个星号**params来收集,这样返回的就是字典而不是元组
        def print_p(x,y,z=3, *pops, **keypars):
            print x,y,z
            print pops
            print keypars
        >>>print_p(1,2,3,4,5,67,a='12',b='hel',c=3)
        1 2 3
        (4, 5, 67)
        {'a': '12', 'c': 3, 'b': 'hel'}
        >>>print_p(1,2)
        1 2 3
        ()
        {}
    可以使用星号,两个星号在调用的时候传递更多的数据(元组/字典)
        >>> def add(x,y):
            return x+y

        >>> params=(1,2)
        >>> add(*params)
        3
        >>> def with_stars(**kwds):
            print kwds['name'],'is',kwds['age'],'years old'

        >>> def without_stars(kwds):
            print kwds['name'],'is',kwds['age'],'years old'

        >>> args = {'name':'tommy','age':'28'}
        >>> with_stars(**args)
        tommy is 28 years old
        >>> without_stars(args)
        tommy is 28 years old

        >> def story(**kwds):
            return 'Once upon a time , there was a  %(job)s called %(name)s.' % kwds

        >>> print story(job='king', name='tommy')
        Once upon a time , there was a  king called tommy.
        >>> print story(name='Tommy X', job='light knight')
        Once upon a time , there was a  light knight called Tommy X.
        >>> params={'job':'lanuage','name':'php'}
        >>> print story(**params)
        Once upon a time , there was a  lanuage called php.
        >>> del params['job']
        >>> params
        {'name': 'php'}
        >>> print story(job='amazing fast language', **params)
        Once upon a time , there was a  amazing fast language called php.
        >>> 

    globals函数获取全局变量值,vars返回全局变量的字典,locals返回局部变量的字典
        >>> x = 1
        >>> def change_global():
            global x
            x = x+2
            
        >>> change_global()
        >>> x
        3

    map(func, seq[, seq, ...])  对序列中的每个元素应用函数
    filter(func, seq)           返回其函数为真的元素的列表
        >>> def func(x):
            return x.isalnum()
        >>> seq=['tommy','x10','?3','**']
        >>> filter(func, seq)
        ['tommy', 'x10']
    reduce(func, seq [,initial])等同于func(func(seq[0], seq[1], seq[2],...))
    sum(seq)                    返回seq中所有元素的和
    apply(func[,args[, kwargs]])调用函数, 可以提供参数

Object 对象
    多态,polymorphism 意味着可以对不同类的对象使用同样的操作.
    封装,encapsulation,对外部世界隐藏对象的工作细节
    继承,inheritance,以通用的类为基础建立专门的类对象

    标准库random中包含choice函数,可以从序列中随机选出元素,然后给变量赋值
        >>> from random import choice
        >>> x = choice(['hello,wordl',[1,2,'e','e',4]])
        >>> x
        'hello,wordl'
        >>> x.count('e')
        1
        >>> x.count('l')
        3
        >>> x= choice(range(1000))
        >>> any numbers in the range of 1000.

    类, 默认新式类需要加载下面的内容.
        __metaclass__ = type #确定使用新式类

        class Person:
            def setName(self, name):
                self.name = name

            def geName(self):
                return self.name

            def greet(self):
                print "Hello, World! I'm %s ." % self.name

        >>> foo = Person()
        >>> bar = Person()
        >>> foo.setName('haha1')
        >>> bar.setName('haha2')
        >>> foo.greet()
        Hello,world! I'm haha1. 
        >>> bar.greet()
        Hello,world! I'm haha2. 
        >>> foo.name
        'haha1'
        >>> bar.name
        'haha2'

    python并不直接支持私有方式. 不过可以在方法/变量前加上__ 双下划线. 实际上也可以通过 "_类名__方法名"来直接从外部访问
        >>> class secretive:
            def __inaccessible(self):
                print "Bet you can't see..."
            def accessible(self):
                print "You can see:"
                self.__inaccessible()

        >>> foo = secretive()
        >>> foo.accessible()
        You can see:
        Bet you can't see...
        >>> foo.__inaccessible()

        Traceback (most recent call last):
          File "<pyshell#31>", line 1, in <module>
            foo.__inaccessible()
        AttributeError: secretive instance has no attribute '__inaccessible'
        >>> foo._secretive__inaccessible
        <bound method secretive.__inaccessible of <__main__.secretive instance at 0x17baf38>>
    单下划线,都不会被带星号的import语言导入(from module import *)

    类的命名空间 
        下面两个语句几乎等价
        def foo(x): return x*x
        foo = lambda x:x*x
        在类里面, 可以直接定义一个可供所有成员(实例)访问的变量.用init来初始化所有实例.
            >>> class MC:
                members = 0
                def init(self):
                    MC.members+=1

                
            >>> m1=MC()
            >>> m1.init()
            >>> MC.members
            1
            >>> m2=MC()
            >>> m2.init()
            >>> MC.members
            2

    对类进行修改,就叫子类对超类的扩展
        >>> class F:
            def init(self):
                self.blocked=[]
            def filter(self, sequence):
                return [x for x in sequence if x not in self.blocked]
            
        >>> class sf(F):
            def init(self):
                self.blocked=['SPAM']
                
        >>> f=F()
        >>> f.init()
        >>> f.filter([1,2,3])
        [1, 2, 3]
        >>> s=sf()
        >>> s.init()
        >>> s.filter(['spam','spam','eee','haha','spam','SPAM'])
        ['spam', 'spam', 'eee', 'haha', 'spam']
    查看一个类是否是另外一个类的子类, 可以用内建的issubclass函数,issubclass(子类,超类)
        >>> issubclass(sf,F)
        True
    如果想要知道已知类的基类(们),可以用__bases__:
        >>> sf.__bases__
        (<class __main__.F at 0x17cdce8>,)
        >>> F.__bases__
        ()
    也可以用isinstance方法来检查一个对象是否是一个类的实例
        >>> s=sf()
        >>> isinstance(s, sf)
        True
        >>> isinstance(s,F)
        True
        >>> isinstance(s,str)
        False
    如果只想支持一个对象属于哪个类,可以使用__class__特性
        >>> s.__class__
        <class __main__.sf at 0x17cdd50>

    多重继承multiple
    inheritance,如果一个方法从多个超类继承(也就是多个相同名字的不同方法),就需要注意超类的顺序.先继承的类中的方法会重写后继承的类中的方法.(注意是前面的重写后面的)
        下例中子类TC不做任何事,它从自己的超类继承所有
        class Calculator:
            def calculate(self, expression):
                self.value = eval(expression)

        class Talker:
            def talk(self):
                print 'Hi, my value is', self.value

        class TalkingCalculator(Calculator, Talker):
            pass

        tc = TalkingCalculator()
        tc.calculate('1+20*20')
        tc.talk()

    使用hasattr(x,'__call__')来代替在python3.0弃用的callable,检测所需方法是否存在,
    getattr函数,允许提供默认值以便在特性(函数)不存在时调用, 对应的是setattr函数,可以用来设置对象的特性.
        >>> setattr(tc, 'name', 'Mr.Tom')
        >>> tc.name
        'Mr.Tom'
        >>>callable(getattr(tc,'talk', 'NNN'))
        True
        >>> hasattr(tc,'echo')
        False
    如果要查看对象内所有存储的值,可以用__dict__特性.
        >>> tc.__dict__
        {'name': 'Mr.Tom', 'value': 401}
    Type(object) 返回对象的类型.
    callable(object)
    getattr(object,name[,default])
    hasattr(object, name)
    isinstance(object, class)
    issubclass(A,B)
    random.choice(sequence)
    setattr(object, name, value)

异常
    python用异常对象(exception object)来表示异常情况,如果异常未被处理或捕捉,程序就用回溯(traceback,一种错误信息)终止执行
    为了引发异常,可以用一个exception的子类或者实例参数调用raise语句. 使用时,程序会自动创建类的实例
        >>> raise Exception
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        Exception
        >>> raise Exception('Hello wrong!')
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        Exception: Hello wrong!
    可以查看exceptions模块用dir函数来列出所有的模块内容
        >>>import exceptions
        >>>dir(Exceptions)
        ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', '...']
    所有异常都可以用在raise语句中
        >>>raise BaseException
          ...
    一些内建常用的异常
        Exception 所有异常的基类
        AttributeError 特性引用/赋值失败时引发
        IOError     试图打开不存在文件(包括其他情况)引发
        IndexError  在使用序列中不存在的索引时引发
        KeyError    在使用映射中不存在的键时引发
        NameError   在找不到名字(变量)时引发
        SyntaxError 在代码为错误形式时引发
        TypeError   在内建操作或者函数应用于错误类型的对象时引发
        ValueError  在内建操作或者函数应用于正确类型的对象,但是该对象使用不合适的值时引发
        ZeroDivisionError   在除法或者模除操作的第二个参数为0时引发
    可以自己自定义异常类,使用继承Exception
        class someCustomeException(Exception): pass
    捕捉异常
            try:
                x = input('Enter the first number: ')
                y = input('Enter the second number: ')
                print x/y
            except ZeroDivisionError:
                print "The second name can't be zero"
    如果没有捕捉到异常,就会被传播到调用的函数中,如果那里也没有捕获,这些异常最终会浮到程序的最顶层.也就是说可以捕捉到其他人的函数中所引发的异常.
    如果捕捉到了异常,但是又想重新引发它.(传递异常,不进行处理),可以用不带参数的raise
        class MuffledCalc:
            muffled = False
            def calc(self, expr):
                try:
                    return eval(expr)
                except ZeroDivisionError:
                    if  self.muffled:
                        print 'Division by zero is illegal!'
                    else:
                        raise

        ca = MuffledCalc()
        ca.calc('10/2')
#ca.calc('10/0')
        ca.muffled = True
        ca.calc('10/0')
    多个异常,可以多个调用,在上面的代码中继续加入excep TypeError: ......
    或者是用一个块来捕捉多个类型异常, 可以将它们作为元组列出
        try:
            ...
        except(ZeroDivisionError, TypeError, NameError):
            print 'xxx...'
    如果想要打印异常的内容.在except子句中访问异常对象本身,用e 
        python 2.x  except(ZeroDivisionError, TypeError), e:
                        print e
        python 3.x  except(ZeroDivisionError, TypeError) as e:
                        print e
    当没有异常引发的时候, 可以用else子句的break来退出, 也就是说,如果程序中有错误,就不断要求重新输入,直到没有错误
        while True:
            try:
                x = input('Enter the first number: ')
                y = input('Enter the second number: ')
                value = x/y
                print 'x/y is', value
            except Exception,e:
                print 'Invalid input: ',e
                print 'pls try agin!'
            else:
                break
    finally子句,用来在可能的异常后进行清理.和try子句联合
        x = None
        try:
            x = 1/0
        except NameError:
            print 'UNknown variable'
        else:
             print "That went well!"
        finally:
            print 'Cleaning UP'
            #可以在finally这里执行一些关闭文件/网络套接字, 非常有用

