5. 数据结构
    5.1. 关于列表
    list.append(x) 把一个元素添加到链表的结尾，相当于 a[len(a):] = [x] 。
    list.extend(L) 将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L 。
    list.insert(i, x) 在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个链表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。
    list.remove(x) 删除链表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。
    list.pop([i]) 从链表的指定位置删除元素，并将其返回。如果没有指定索引， a.pop() 返回最后一个元素。元素随即从链表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）
    list.index(x) 返回链表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。
    list.count(x) 返回 x 在链表中出现的次数。
    list.sort() 对链表中的元素就地进行排序。
    list.reverse() 就地倒排链表中的元素。
        >>> a = [66.25, 333, 333, 1, 1234.5]
        >>> print a.count(333), a.count(66.25), a.count('x')
        2 1 0
        >>> a.insert(2, -1)
        >>> a.append(333)
        >>> a
        [66.25, 333, -1, 333, 1, 1234.5, 333]
        >>> a.index(333)
        1
        >>> a.remove(333)
        >>> a
        [66.25, -1, 333, 1, 1234.5, 333]
        >>> a.reverse()
        >>> a
        [333, 1234.5, 1, 333, -1, 66.25]
        >>> a.sort()
        >>> a
        [-1, 1, 66.25, 333, 333, 1234.5]

    5.1.1. 把链表当作堆栈使用
    链表方法使得链表可以很方便的做为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来
    5.1.2. 把链表当作队列使用
    你也可以把链表当做队列使用，队列作为特定的数据结构，最先进入的元素最先释放（先进先出）。不过，列表这样用效率不高。相对来说从列表末尾添加和弹出很快；在头部插入和弹出很慢（因为，为了一个元素，要移动整个列表中的所有元素）。
    要实现队列，使用 collections.deque ，它为在首尾两端快速插入和删除而设计。
        >>> from collections import deque
        >>> queue = deque(["Eric", "John", "Michael"])
        >>> queue.append("Terry")           # Terry arrives
        >>> queue.append("Graham")          # Graham arrives
        >>> queue.popleft()                 # The first to arrive now leaves
        'Eric'
        >>> queue.popleft()                 # The second to arrive now leaves
        'John'
        >>> queue                           # Remaining queue in order of arrival
        deque(['Michael', 'Terry', 'Graham'])
    5.1.3. 函数式编程工具
    对于链表来讲，有三个内置函数非常有用: filter(), map(), 以及 reduce()。
        filter(function, sequence) 返回一个 sequence（序列），包括了给定序列中所有调用 function(item) 后返回值为 true 的元素。（如果可能的话，会返回相同的类型）。如果该 序列 （sequence） 是一个 string （字符串）或者 tuple （元组），返回值必定是同一类型，否则，它总是 list 。例如，以下程序可以计算部分素数:
            >>> def f(x): return x % 2 != 0 and x % 3 != 0
            ...
            >>> filter(f, range(2, 25))
            [5, 7, 11, 13, 17, 19, 23]
        map(function, sequence) 为每一个元素依次调用 function(item) 并将返回值组成一个链表返回。例如，以下程序计算立方:
            >>> def cube(x): return x*x*x
            ...
            >>> map(cube, range(1, 11))
            [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
        可以传入多个序列，函数也必须要有对应数量的参数，执行时会依次用各序列上对应的元素来调用函数（如果某些序列比其它的短，就用 None 来代替）。如果把 None 做为一个函数传入，则直接返回参数做为替代。例如:
            >>> seq = range(8)
            >>> def add(x, y): return x+y
            ...
            >>> map(add, seq, seq)
            [0, 2, 4, 6, 8, 10, 12, 14]
        reduce(function, sequence) 返回一个单值，它是这样构造的：首先以序列的前两个元素调用函数 function，再以返回值和第三个参数调用，依次执行下去。例如，以下程序计算 1 到 10 的整数之和:
            >>> def add(x,y): return x+y
            ...
            >>> reduce(add, range(1, 11))
            55
        如果序列中只有一个元素，就返回它，如果序列是空的，就抛出一个异常。
        可以传入第三个参数作为初始值。如果序列是空的，就返回初始值，否则函数会先接收初始值和序列的第一个元素，然后是返回值和下一个元素，依此类推。例如:
            >>> def sum(seq):
            ...     def add(x,y): return x+y
            ...     return reduce(add, seq, 0)
            ...
            >>> sum(range(1, 11))
            55
            >>> sum([])
            0
        不要像示例中这样定义 sum() ：因为合计数值是一个通用的需求，早已有内置的 sum(sequence) 函数，非常好用

    5.1.4. 列表推导式
    列表推导式为从序列中创建列表提供了一个简单的方法。 普通的应用程序通过将一些操作应用于序列的每个成员并通过返回的元素创建列表，或者通过满足特定条件的元素创建子序列。
    例如, 假设我们创建一个 squares 列表, 可以像下面方式:
        >>> squares = []
        >>> for x in range(10):
        ...     squares.append(x**2)
        ...
        >>> squares
        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    我们同样能够达到目的采用下面的方式:
        squares = [x**2 for x in range(10)]
    这也相当于 squares = map(lambda x: x**2, range(10)), 但是上面的方式显得简洁以及具有可读性.
                    map 调用匿名函数，执行x*x，列表是range(10)
    列表推导式由包含一个表达式的括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。 结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。
    例如，如下的列表推导式结合两个列表的元素，如果元素之间不相等的话:
        >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
        [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
    等同于:
        >>> combs = []
        >>> for x in [1,2,3]:
        ...     for y in [3,1,4]:
        ...         if x != y:
        ...             combs.append((x, y))
        ...
        >>> combs
        [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
    列表推导式可使用复杂的表达式和嵌套函数:
        >>> from math import pi
        >>> [str(round(pi, i)) for i in range(1, 6)]
        ['3.1', '3.14', '3.142', '3.1416', '3.14159']

    5.1.4.1. 嵌套的列表推导式
    列表推导式可以嵌套。
    考虑以下的 3x4 矩阵， 一个列表中包含三个长度为4的列表:
        >>> matrix = [
        ...     [1, 2, 3, 4],
        ...     [5, 6, 7, 8],
        ...     [9, 10, 11, 12],
        ... ]
    现在，如果你想交换行和列，可以用嵌套的列表推导式:
        >>> [[row[i] for row in matrix] for i in range(4)]
        [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
    像前面看到的，嵌套的列表推导式是对 for 后面的内容进行求值，所以上例就等价于:
        >>> transposed = []
        >>> for i in range(4):
        ...     transposed.append([row[i] for row in matrix])
        ...
        >>> transposed
        [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
    反过来说，如下也是一样的:
        >>> transposed = []
        >>> for i in range(4):
        ...     # the following 3 lines implement the nested listcomp
        ...     transposed_row = []
        ...     for row in matrix:
        ...         transposed_row.append(row[i])
        ...     transposed.append(transposed_row)
        ...
        >>> transposed
        [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
    在实际中，你应该更喜欢使用内置函数组成复杂流程语句。 对此种情况 zip() 函数将会做的更好:
        >>> list(zip(*matrix))
        [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
